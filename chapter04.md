# فصل ۴ – دستکاری فایل‌ها و پوشه‌ها (Manipulating Files and Directories)

---

## مقدمه

اکنون آماده‌ی انجام کار واقعی هستیم!
این فصل دستورات زیر را معرفی می‌کند:

* **cp** – کپی کردن فایل‌ها و پوشه‌ها
* **mv** – جابه‌جا کردن یا تغییر نام فایل‌ها و پوشه‌ها
* **mkdir** – ایجاد پوشه‌ها
* **rm** – حذف فایل‌ها و پوشه‌ها
* **ln** – ایجاد لینک‌های سخت (Hard Link) و نمادین (Symbolic Link)

این پنج دستور از پرکاربردترین دستورات لینوکس هستند.
آن‌ها برای دستکاری فایل‌ها و دایرکتوری‌ها مورد استفاده قرار می‌گیرند.

---

## چرا به‌جای فایل‌منیجر از خط فرمان استفاده کنیم؟

صادقانه بگوییم، برخی از کارهایی که این دستورات انجام می‌دهند، با استفاده از یک **مدیر فایل گرافیکی (File Manager)** راحت‌تر انجام می‌شوند.
برای مثال، در یک مدیر فایل می‌توانیم:

* فایل را از یک پوشه به پوشه‌ی دیگر بکشیم و رها کنیم (Drag & Drop)
* فایل‌ها را **برش (Cut)** و **جای‌گذاری (Paste)** کنیم
* فایل‌ها را حذف کنیم و غیره

پس چرا باید از این برنامه‌های قدیمی خط فرمان استفاده کنیم؟

پاسخ در دو واژه خلاصه می‌شود: **قدرت (Power)** و **انعطاف‌پذیری (Flexibility)**.
در حالی که انجام کارهای ساده با مدیر فایل آسان است،
کارهای پیچیده‌تر با خط فرمان **سریع‌تر و دقیق‌تر** انجام می‌شوند.

برای مثال:
فرض کنید می‌خواهیم تمام فایل‌های HTML را از یک پوشه به پوشه‌ی دیگر کپی کنیم،
اما فقط فایل‌هایی را کپی کنیم که در مقصد وجود ندارند یا نسخه‌ی موجود در مقصد قدیمی‌تر است.
این کار با یک فایل‌منیجر تقریباً غیرممکن است،
اما در خط فرمان خیلی راحت انجام می‌شود:

```bash
cp -u *.html destination
```

---

## Wildcards (کاراکترهای عام یا جایگزین)

پیش از آنکه استفاده از این دستورات را آغاز کنیم، باید درباره‌ی قابلیتی از **شل (Shell)** صحبت کنیم که باعث می‌شود این دستورات بسیار قدرتمند باشند.
از آن‌جا که شل به‌طور گسترده‌ای با نام فایل‌ها سروکار دارد،
کاراکترهای ویژه‌ای را برای مشخص کردن سریع گروهی از فایل‌ها فراهم می‌کند.

به این کاراکترهای ویژه **Wildcards (وایلدکارت)** گفته می‌شود.
استفاده از وایلدکارت‌ها – که به آن **Globbing (گلابینگ)** نیز می‌گویند – به ما اجازه می‌دهد فایل‌ها را بر اساس **الگوهای متنی** انتخاب کنیم.

---

### جدول ۴-۱: Wildcards

| وایلدکارت                          | معنی                                                                            |
| ---------------------------------- | ------------------------------------------------------------------------------- |
| `*`                                | با هر تعداد از کاراکترها مطابقت دارد.                                           |
| `?`                                | با هر کاراکتر تکی مطابقت دارد.                                                  |
| `[characters]`                     | با هر کاراکتری که عضوی از مجموعه‌ی مشخص‌شده باشد مطابقت دارد.                   |
| `[!characters]` یا `[^characters]` | با هر کاراکتری که عضوی از مجموعه‌ی مشخص‌شده **نباشد** مطابقت دارد.              |
| `[[:class:]]`                      | با هر کاراکتری که عضوی از **کلاس مشخص‌شده (Character Class)** باشد مطابقت دارد. |

---

### جدول ۴-۲: کلاس‌های کاراکتری رایج (Commonly Used Character Classes)

| کلاس کاراکتری | توضیح                                                     |
| ------------- | --------------------------------------------------------- |
| `[:alnum:]`   | با هر کاراکتر **حرف یا عددی (الفبایی–عددی)** مطابقت دارد. |
| `[:alpha:]`   | با هر **حرف الفبایی** مطابقت دارد.                        |
| `[:digit:]`   | با هر **عدد** مطابقت دارد.                                |
| `[:lower:]`   | با هر **حرف کوچک** مطابقت دارد.                           |
| `[:upper:]`   | با هر **حرف بزرگ** مطابقت دارد.                           |

---

استفاده از وایلدکارت‌ها این امکان را به ما می‌دهد تا **الگوهای پیچیده و پیشرفته‌ای برای انتخاب نام فایل‌ها** بسازیم.
در جدول زیر، چند نمونه از این الگوها و فایل‌هایی که با آن‌ها مطابقت دارند آمده است:

---

### جدول ۴-۳: مثال‌هایی از Wildcard

| الگو (Pattern)           | فایل‌هایی که مطابقت دارند                                                                      |
| ------------------------ | ---------------------------------------------------------------------------------------------- |
| `*`                      | تمام فایل‌ها                                                                                   |
| `g*`                     | هر فایلی که با حرف **g** آغاز شود                                                              |
| `b*.txt`                 | هر فایلی که با **b** آغاز شود، سپس هر تعدادی کاراکتر داشته باشد، و در نهایت با `.txt` تمام شود |
| `Data???`                | هر فایلی که با **Data** آغاز شود و دقیقاً سه کاراکتر پس از آن بیاید                            |
| `[abc]*`                 | هر فایلی که با یکی از حروف **a، b یا c** آغاز شود                                              |
| `BACKUP.[0-9][0-9][0-9]` | هر فایلی که با **BACKUP.** آغاز شود و پس از آن دقیقاً سه رقم بیاید                             |
| `[[:upper:]]*`           | هر فایلی که با یک **حرف بزرگ** آغاز شود                                                        |
| `[![:digit:]]*`          | هر فایلی که با **عدد آغاز نمی‌شود**                                                            |
| `*[[:lower:]123]`        | هر فایلی که با یک **حرف کوچک** یا یکی از اعداد **۱، ۲ یا ۳** پایان یابد                        |

---

وایلدکارت‌ها را می‌توان با هر دستوری که از نام فایل‌ها به‌عنوان آرگومان استفاده می‌کند به کار برد.
در فصل ۷ با این موضوع بیشتر آشنا خواهیم شد:
**«دیدن دنیا از دیدگاه شل (Seeing the World as the Shell Sees It)».**


# محدوده‌های کاراکتری (Character Ranges)

اگر پیش‌تر با سیستم‌های مشابه یونیکس (Unix-like) کار کرده باشید
یا کتاب‌های دیگری درباره‌ی این موضوع خوانده باشید،
ممکن است با نمادهای `[A-Z]` و `[a-z]` برای نمایش محدوده‌ی کاراکترها برخورد کرده باشید.

این نمادها در گذشته، در نسخه‌های قدیمی یونیکس و لینوکس،
روش استاندارد برای مشخص کردن محدوده‌ای از حروف بودند.
برای مثال، `[A-Z]` نشان‌دهنده‌ی تمام حروف بزرگ انگلیسی و `[a-z]` نشان‌دهنده‌ی تمام حروف کوچک بود.

اما باید توجه داشته باشید که در نسخه‌های جدید لینوکس،
این یادداشت‌ها ممکن است نتیجه‌ی مورد انتظار را تولید نکنند،
مگر آن‌که سیستم به‌درستی پیکربندی شده باشد (به‌ویژه از نظر **Locale** و زبان).

بنابراین، بهتر است از آن‌ها استفاده نکنید و به جای آن از **کلاس‌های کاراکتری (Character Classes)**
که در جدول قبل معرفی شد (`[:upper:]`, `[:lower:]`, `[:alpha:]` و غیره) بهره ببرید.
این کلاس‌ها قابل اطمینان‌تر و سازگار با محیط‌های مختلف هستند.

---

## فایل‌های نقطه‌ای (Dot Files)

اگر با دستور `ls` و گزینه‌ی `-a` به پوشه‌ی خانگی خود نگاه کنیم،
تعداد زیادی فایل و پوشه را مشاهده خواهیم کرد که نام آن‌ها با یک نقطه (`.`) آغاز می‌شود.

همان‌طور که پیش‌تر آموختیم،
این فایل‌ها **پنهان (Hidden Files)** هستند.
پنهان بودن، یک ویژگی خاص فایل نیست،
بلکه فقط به این معناست که نام فایل با یک نقطه شروع می‌شود
و در نتیجه، در خروجی `ls` نمایش داده نمی‌شود مگر آن‌که از گزینه‌های `-a` یا `-A` استفاده کنیم.

این ویژگی در مورد **وایلدکارت‌ها** نیز صدق می‌کند.
یعنی فایل‌های پنهان در نتایج الگوهای وایلدکارت ظاهر نمی‌شوند،
مگر آن‌که صراحتاً الگویی مانند `.*` را بنویسیم.

اما اگر این کار را انجام دهیم،
نتیجه شامل دو مدخل خاص نیز خواهد بود:

* `.` → اشاره به پوشه‌ی فعلی (**Current Directory**)
* `..` → اشاره به پوشه‌ی والد (**Parent Directory**)

برای جلوگیری از نمایش این دو مورد،
می‌توان از الگوهای زیر استفاده کرد:

```bash
.[!.]*
```

یا

```bash
.??*
```

هر دوی این الگوها فایل‌های پنهان واقعی را فهرست می‌کنند
اما `.` و `..` را حذف می‌کنند.

---

✅ **نکته:**
در لینوکس و یونیکس، فایل‌های پنهان معمولاً برای ذخیره‌ی **تنظیمات برنامه‌ها و کاربر** استفاده می‌شوند.
برای مثال:

* `.bashrc` → تنظیمات پوسته‌ی Bash
* `.profile` → تنظیمات ورود کاربر
* `.gitconfig` → پیکربندی Git

بنابراین، در اغلب موارد نیازی به تغییر یا حذف فایل‌های نقطه‌ای نیست مگر آن‌که دقیقاً بدانید چه می‌کنید.

---

### 🟢 پایان بخش دوم

در بخش بعدی، سراغ قسمت بعدی فصل می‌رویم:
**Wildcards در محیط گرافیکی (GUI)** و دستور **`mkdir`** برای ایجاد دایرکتوری‌ها.

# وایلدکارت‌ها در محیط گرافیکی (Wildcards Work in the GUI Too)

وایلدکارت‌ها فقط در خط فرمان کاربرد ندارند؛
بلکه در برخی از **مدیران فایل گرافیکی (Graphical File Managers)** نیز پشتیبانی می‌شوند.
این موضوع آن‌ها را حتی ارزشمندتر می‌کند، زیرا می‌توان از همان الگوهای قدرتمند در محیط‌های تصویری نیز استفاده کرد.

---

## نمونه‌ها

### در Nautilus (مدیر فایل در محیط GNOME)

می‌توانید کلیدهای ترکیبی `Ctrl + S` را فشار دهید
و یک الگوی انتخاب فایل با استفاده از وایلدکارت وارد کنید.
در این حالت، تمام فایل‌هایی که با الگوی شما مطابقت دارند، در پوشه‌ی فعلی انتخاب می‌شوند.

### در Dolphin و Konqueror (مدیران فایل در محیط KDE)

می‌توانید مستقیماً در نوار مسیر (**Location Bar**) از وایلدکارت استفاده کنید.
برای مثال، اگر بخواهید تمام فایل‌هایی را که در مسیر `/usr/bin` با حرف کوچک **u** شروع می‌شوند ببینید، کافی است عبارت زیر را در نوار مسیر وارد کنید:

```
/usr/bin/u*
```

و مدیر فایل به‌طور خودکار فقط فایل‌های مطابق با این الگو را نمایش می‌دهد.

---

📌 **نکته:**
بسیاری از ایده‌هایی که در ابتدا در **رابط خط فرمان (Command Line Interface)** وجود داشتند، بعدها به رابط‌های گرافیکی نیز راه پیدا کرده‌اند.
این یکی از دلایلی است که باعث می‌شود **محیط دسکتاپ لینوکس** تا این اندازه قدرتمند و منعطف باشد.

---

## دستور `mkdir` – ایجاد دایرکتوری‌ها (Create Directories)

دستور **`mkdir`** برای ایجاد پوشه‌ها (دایرکتوری‌ها) استفاده می‌شود.
شکل کلی استفاده از آن به‌صورت زیر است:

```bash
mkdir directory...
```

علامت سه‌نقطه (`...`) در مستندات لینوکس به این معناست که آرگومان می‌تواند **تکرار شود**.
به بیان دیگر، می‌توانید چندین پوشه را در یک دستور بسازید.

---

### مثال‌ها

ایجاد یک پوشه به نام `dir1`:

```bash
mkdir dir1
```

ایجاد سه پوشه هم‌زمان:

```bash
mkdir dir1 dir2 dir3
```

در این حالت، سه پوشه به نام‌های `dir1`، `dir2` و `dir3` ساخته می‌شوند.

---

📘 **نکته:**
اگر در مسیر موردنظر مجوز (**Permission**) لازم برای نوشتن نداشته باشید،
دستور `mkdir` با خطای «Permission denied» مواجه می‌شود.
در چنین حالتی، باید از `sudo` برای اجرای دستور با سطح دسترسی مدیر استفاده کنید:

```bash
sudo mkdir /opt/newfolder
```

---

### 🟢 پایان بخش سوم

در بخش بعدی، سراغ دستورات کاربردی‌تر خواهیم رفت:
**`cp` (کپی کردن فایل‌ها و دایرکتوری‌ها)** همراه با جدول کامل گزینه‌ها و مثال‌های واقعی.


# دستور cp – کپی کردن فایل‌ها و دایرکتوری‌ها (Copy Files and Directories)

دستور **`cp`** برای کپی کردن فایل‌ها یا دایرکتوری‌ها استفاده می‌شود.
این دستور دو شیوه‌ی اصلی برای استفاده دارد:

---

### ۱. کپی یک فایل یا دایرکتوری به مقصد جدید

```bash
cp item1 item2
```

در این حالت، فایل یا پوشه‌ی `item1` در مسیر یا نام جدیدی با عنوان `item2` کپی می‌شود.
اگر مقصد موجود باشد، محتوای آن **بازنویسی (overwrite)** می‌شود.

---

### ۲. کپی چند فایل یا پوشه درون یک دایرکتوری

```bash
cp item... directory
```

در این حالت، چندین فایل یا پوشه (که با فاصله از هم جدا شده‌اند)
درون دایرکتوری مشخص‌شده کپی می‌شوند.

برای مثال:

```bash
cp file1 file2 dir1
```

فایل‌های `file1` و `file2` درون دایرکتوری `dir1` کپی می‌شوند.
دایرکتوری مقصد (`dir1`) باید از قبل وجود داشته باشد.

---

## گزینه‌های مفید cp (Useful Options)

جدول زیر برخی از گزینه‌های پرکاربرد دستور `cp` را نشان می‌دهد.

### جدول ۴-۴: گزینه‌های cp

| گزینه | گزینه‌ی بلند    | توضیح                                                                                                                                                                                          |
| ----- | --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-a`  | `--archive`     | فایل‌ها و دایرکتوری‌ها را همراه با تمام ویژگی‌هایشان (مالکیت، مجوزها و غیره) کپی می‌کند. به‌طور معمول، فایل‌های کپی‌شده خصوصیات کاربر فعلی را می‌گیرند، اما با این گزینه همه‌چیز حفظ می‌شود.   |
| `-i`  | `--interactive` | پیش از بازنویسی یک فایل موجود، از کاربر تأیید می‌گیرد. در حالت عادی، `cp` بدون هشدار فایل‌ها را بازنویسی می‌کند.                                                                               |
| `-r`  | `--recursive`   | دایرکتوری‌ها و محتوای درونشان را به‌صورت بازگشتی کپی می‌کند. برای کپی دایرکتوری‌ها، باید این گزینه یا `-a` را استفاده کنید.                                                                    |
| `-u`  | `--update`      | فقط فایل‌هایی را کپی می‌کند که در مقصد وجود ندارند یا نسخه‌ی جدیدتری نسبت به فایل مقصد دارند. این گزینه در انتقال حجم زیاد فایل‌ها بسیار مفید است، زیرا از کپی فایل‌های تکراری جلوگیری می‌کند. |
| `-v`  | `--verbose`     | هنگام اجرای دستور، پیام‌های توضیحی درباره‌ی عملیات انجام‌شده نمایش می‌دهد.                                                                                                                     |

---

## مثال‌های کاربردی cp

در جدول زیر چند نمونه از کاربرد دستور `cp` را می‌بینید.

### جدول ۴-۵: مثال‌های cp

| دستور                 | نتیجه                                                                                                                                                                                                                                         |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cp file1 file2`      | فایل `file1` را به `file2` کپی می‌کند. اگر `file2` وجود داشته باشد، محتوای آن بازنویسی می‌شود؛ در غیر این صورت فایل جدیدی ایجاد می‌شود.                                                                                                       |
| `cp -i file1 file2`   | مانند دستور قبل، اما قبل از بازنویسی `file2` از کاربر تأیید می‌گیرد.                                                                                                                                                                          |
| `cp file1 file2 dir1` | فایل‌های `file1` و `file2` را درون دایرکتوری `dir1` کپی می‌کند (دایرکتوری باید موجود باشد).                                                                                                                                                   |
| `cp dir1/* dir2`      | با استفاده از وایلدکارت، همه‌ی فایل‌های موجود در `dir1` را درون `dir2` کپی می‌کند (دایرکتوری مقصد باید وجود داشته باشد).                                                                                                                      |
| `cp -r dir1 dir2`     | کل محتوای دایرکتوری `dir1` را به دایرکتوری `dir2` کپی می‌کند. اگر `dir2` وجود نداشته باشد، ایجاد می‌شود و پس از کپی، حاوی همان محتویات `dir1` خواهد بود. اگر `dir2` از قبل وجود داشته باشد، آنگاه `dir1` (و محتویاتش) درون `dir2` کپی می‌شود. |

---

📘 **نکته آموزشی:**
در صورت نیاز به پشتیبان‌گیری از ساختار کامل یک پوشه،
بهترین ترکیب استفاده از دستور زیر است:

```bash
cp -av source destination
```

گزینه‌ی `-a` تمام ویژگی‌ها را حفظ می‌کند و `-v` گزارش عملیات را نمایش می‌دهد.

---

### 🟢 پایان بخش چهارم

در بخش بعدی، سراغ دستور بعدی می‌رویم:
**`mv` – جابه‌جایی و تغییر نام فایل‌ها و دایرکتوری‌ها (Move and Rename Files and Directories)**


# دستور mv – جابه‌جا کردن و تغییر نام فایل‌ها (Move and Rename Files)

دستور **`mv`** برای **جابه‌جا کردن (Move)** و **تغییر نام (Rename)** فایل‌ها و دایرکتوری‌ها استفاده می‌شود.
این دستور از نظر نحو (Syntax) بسیار شبیه به دستور `cp` است،
اما تفاوت مهم آن در این است که پس از اجرای عمل جابه‌جایی یا تغییر نام،
فایل اصلی دیگر وجود ندارد — یعنی عملیات انتقال، برخلاف کپی، فایل را حذف می‌کند.

---

### ۱. تغییر نام یا جابه‌جایی یک فایل/دایرکتوری

```bash
mv item1 item2
```

در این حالت، فایل یا دایرکتوری با نام `item1`
به نام یا مسیر جدیدی با عنوان `item2` منتقل یا تغییر نام داده می‌شود.

---

### ۲. جابه‌جایی چند فایل یا دایرکتوری به داخل یک پوشه

```bash
mv item... directory
```

در این حالت، چند فایل یا پوشه (جداشده با فاصله)
به دایرکتوری مشخص‌شده منتقل می‌شوند.

---

## گزینه‌های مفید mv (Useful Options)

دستور `mv` بسیاری از گزینه‌های خود را با `cp` مشترک دارد.
در جدول زیر مهم‌ترین گزینه‌ها آورده شده است:

### جدول ۴-۶: گزینه‌های mv

| گزینه | گزینه‌ی بلند    | توضیح                                                                                                            |
| ----- | --------------- | ---------------------------------------------------------------------------------------------------------------- |
| `-i`  | `--interactive` | پیش از بازنویسی فایل موجود در مقصد، از کاربر تأیید می‌گیرد. در حالت عادی `mv` بدون هشدار فایل را جایگزین می‌کند. |
| `-u`  | `--update`      | فقط فایل‌هایی را منتقل می‌کند که در مقصد وجود ندارند یا جدیدتر از نسخه‌ی موجود هستند.                            |
| `-v`  | `--verbose`     | در هنگام اجرا، پیام‌های توضیحی درباره‌ی هر عمل انتقال نمایش می‌دهد.                                              |

---

## مثال‌های کاربردی mv

در جدول زیر نمونه‌هایی از کاربردهای رایج دستور `mv` را می‌بینیم.

### جدول ۴-۷: مثال‌های mv

| دستور                 | نتیجه                                                                                                                                                                   |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `mv file1 file2`      | فایل `file1` را به `file2` تغییر نام می‌دهد. اگر `file2` وجود داشته باشد، بازنویسی می‌شود؛ اگر وجود نداشته باشد، ایجاد می‌شود. پس از آن، `file1` دیگر وجود نخواهد داشت. |
| `mv -i file1 file2`   | مانند دستور قبل، اما پیش از بازنویسی `file2` از کاربر تأیید می‌گیرد.                                                                                                    |
| `mv file1 file2 dir1` | فایل‌های `file1` و `file2` را به داخل دایرکتوری `dir1` منتقل می‌کند (دایرکتوری باید از قبل موجود باشد).                                                                 |
| `mv dir1 dir2`        | اگر دایرکتوری `dir2` وجود نداشته باشد، `dir1` را به نام `dir2` تغییر می‌دهد. اگر `dir2` وجود داشته باشد، `dir1` (و محتویات آن) را درون `dir2` منتقل می‌کند.             |

---

📘 **نکات کاربردی:**

* از `mv` می‌توان برای **تغییر نام سریع** فایل‌ها و پوشه‌ها استفاده کرد:

```bash
mv oldname newname
```

* در صورت اشتباه در مسیر مقصد، فایل ممکن است به مکانی غیرمنتظره منتقل شود.
  برای جلوگیری از خطاهای ناخواسته، از گزینه‌ی `-i` استفاده کنید.

---

### 🟢 پایان بخش پنجم

در بخش بعدی، سراغ دستور بعدی می‌رویم:
**`rm` – حذف فایل‌ها و دایرکتوری‌ها (Remove Files and Directories)**
به‌همراه گزینه‌های پرکاربرد، مثال‌ها و هشدارهای مهم.


# دستور rm – حذف فایل‌ها و دایرکتوری‌ها (Remove Files and Directories)

دستور **`rm`** برای حذف (**Delete**) فایل‌ها و دایرکتوری‌ها استفاده می‌شود.
شکل کلی استفاده از آن به این صورت است:

```bash
rm item...
```

در اینجا، `item` می‌تواند یک یا چند فایل یا پوشه باشد که با فاصله از هم جدا شده‌اند.

---

## گزینه‌های مفید rm (Useful Options)

در جدول زیر مهم‌ترین گزینه‌های دستور `rm` آورده شده است:

### جدول ۴-۸: گزینه‌های rm

| گزینه | گزینه‌ی بلند    | توضیح                                                                                                         |
| ----- | --------------- | ------------------------------------------------------------------------------------------------------------- |
| `-i`  | `--interactive` | پیش از حذف هر فایل، از کاربر تأیید می‌گیرد. اگر این گزینه استفاده نشود، فایل‌ها بدون هشدار حذف می‌شوند.       |
| `-r`  | `--recursive`   | به‌صورت بازگشتی دایرکتوری‌ها و تمام زیرشاخه‌های آن‌ها را حذف می‌کند. برای حذف پوشه‌ها، این گزینه الزامی است.  |
| `-f`  | `--force`       | فایل‌های غیرموجود را نادیده می‌گیرد و هیچ پیامی برای تأیید نمایش نمی‌دهد (گزینه‌ی `-i` را نیز بی‌اثر می‌کند). |
| `-v`  | `--verbose`     | در هنگام اجرا، پیام‌های توضیحی درباره‌ی فایل‌ها و دایرکتوری‌های در حال حذف نمایش می‌دهد.                      |

---

## مثال‌های کاربردی rm

در جدول زیر چند مثال از استفاده‌ی دستور `rm` آمده است:

### جدول ۴-۹: مثال‌های rm

| دستور               | نتیجه                                                                                              |
| ------------------- | -------------------------------------------------------------------------------------------------- |
| `rm file1`          | فایل `file1` را بدون هشدار حذف می‌کند.                                                             |
| `rm -i file1`       | همانند مثال قبل، اما پیش از حذف از کاربر تأیید می‌گیرد.                                            |
| `rm -r file1 dir1`  | فایل `file1` و دایرکتوری `dir1` (به‌همراه تمام محتویاتش) را به‌صورت بازگشتی حذف می‌کند.            |
| `rm -rf file1 dir1` | همانند مثال قبل، اما اگر فایل یا دایرکتوری‌ای وجود نداشته باشد، بدون هیچ خطا یا پیام ادامه می‌دهد. |

---

⚠️ **هشدار بسیار مهم: با rm محتاط باشید!**

سیستم‌های شبیه یونیکس مانند لینوکس دستور **بازگردانی حذف (undelete)** ندارند.
به‌عبارت دیگر، زمانی که چیزی را با `rm` حذف می‌کنید، آن فایل برای همیشه از بین می‌رود.
سیستم فرض می‌کند که شما می‌دانید چه می‌کنید.

بنابراین هنگام استفاده از `rm` باید **بسیار دقت و احتیاط** داشته باشید، به‌ویژه در زمان استفاده از **وایلدکارت‌ها (wildcards)**.

---

### مثال خطرناک کلاسیک:

فرض کنید می‌خواهید همه‌ی فایل‌های HTML را در یک پوشه حذف کنید:

```bash
rm *.html
```

این دستور کاملاً درست است.
اما اگر به‌اشتباه بین `*` و `.html` فاصله بگذارید، یعنی:

```bash
rm * .html
```

دستور بالا ابتدا **تمام فایل‌های موجود در پوشه را حذف می‌کند**
و سپس سعی می‌کند فایلی به نام `.html` پیدا کند — که معمولاً وجود ندارد —
و خطا می‌دهد. در نتیجه، **تمام داده‌های پوشه از بین خواهند رفت!**

---

🔹 **نکته ایمنی:**

هرگاه از `rm` به‌همراه وایلدکارت‌ها استفاده می‌کنید،
پیش از اجرای آن، بهتر است ابتدا همان الگو را با دستور `ls` آزمایش کنید تا ببینید کدام فایل‌ها انتخاب می‌شوند:

```bash
ls *.html
```

اگر نتیجه صحیح بود،
با فشردن کلید جهت‌نمای بالا (↑) دستور را بازگردانید و فقط `ls` را به `rm` تغییر دهید:

```bash
rm *.html
```

به این ترتیب از حذف اشتباهی جلوگیری می‌کنید.

---

📘 **نکته حرفه‌ای:**
برای حذف ایمن‌تر فایل‌ها، ابزارهایی مانند **`trash-cli`** یا **`gio trash`** وجود دارند
که فایل‌ها را به **زباله‌دان (Trash)** منتقل می‌کنند تا در صورت نیاز قابل بازگردانی باشند.
اما دستور `rm` همیشه **حذف دائمی** انجام می‌دهد.

---

### 🟢 پایان بخش ششم

در بخش بعدی، سراغ دستور بعدی می‌رویم:
**`ln` – ایجاد لینک‌های سخت و نمادین (Create Hard and Symbolic Links)**،
که یکی از مفاهیم مهم و گاهی گیج‌کننده در لینوکس است.

# دستور ln – ایجاد لینک‌ها (Create Links)

دستور **`ln`** برای ایجاد لینک‌ها بین فایل‌ها و دایرکتوری‌ها به کار می‌رود.
این دستور می‌تواند دو نوع لینک بسازد:

* **لینک سخت (Hard Link)**
* **لینک نمادین یا سمبولیک (Symbolic Link / Symlink)**

---

## شکل کلی استفاده از دستور ln

### ایجاد یک لینک سخت (Hard Link)

```bash
ln file link
```

### ایجاد یک لینک نمادین (Symbolic Link)

```bash
ln -s item link
```

در این حالت، گزینه‌ی `-s` باعث می‌شود که لینک از نوع **نمادین (symbolic)** باشد.
آرگومان `item` می‌تواند فایل یا دایرکتوری باشد.

---

## لینک‌های سخت (Hard Links)

**لینک‌های سخت**، روش اصلی و سنتی سیستم‌عامل یونیکس برای ایجاد لینک‌ها هستند.
در واقع، هر فایل در لینوکس حداقل یک لینک سخت دارد — یعنی همان نام اصلی فایل در سیستم فایل.

زمانی که یک لینک سخت جدید ایجاد می‌کنیم، در واقع **یک نام اضافی برای همان فایل** می‌سازیم.
تمام لینک‌های سخت یک فایل به یک نقطه‌ی داده (**inode**) در دیسک اشاره می‌کنند،
به همین دلیل از نظر سیستم، فایل اصلی و لینک سخت آن **هیچ تفاوتی با هم ندارند**.

---

### محدودیت‌های لینک سخت

1. یک لینک سخت نمی‌تواند به فایلی در یک **سیستم فایل دیگر (پارتیشن دیگر)** اشاره کند.
   یعنی لینک و فایل هدف باید روی یک دیسک یا پارتیشن مشترک باشند.
2. لینک سخت نمی‌تواند به یک **دایرکتوری** اشاره کند — تنها برای فایل‌ها قابل استفاده است.

---

### ویژگی‌های لینک سخت

* در خروجی `ls -l` هیچ نشانه‌ی خاصی برای لینک سخت وجود ندارد.
* اگر یکی از لینک‌ها حذف شود، فایل واقعی باقی می‌ماند تا زمانی که آخرین لینک آن حذف شود.
* هر لینک سخت در واقع یک مسیر مستقل به همان داده‌ی اصلی است.

📘 **نکته مهم:**
در عمل، هنگام حذف یکی از لینک‌ها، تنها «نام» آن حذف می‌شود، نه داده‌ی فایل.
تا زمانی که حداقل یک لینک به فایل وجود داشته باشد، محتوای فایل در سیستم باقی می‌ماند.

---

## لینک‌های نمادین (Symbolic Links)

**لینک‌های نمادین** برای رفع محدودیت‌های لینک‌های سخت معرفی شدند.
آن‌ها یک فایل خاص ایجاد می‌کنند که **حاوی آدرس (Path)** فایل یا پوشه‌ی هدف است.

به زبان ساده، یک **Symbolic Link (یا Symlink)** درست مانند **میانبر (Shortcut)** در ویندوز عمل می‌کند.

---

### ویژگی‌های لینک نمادین

* اگر به فایل اصلی چیزی بنویسیم، از طریق لینک نمادین هم همان تغییر اعمال می‌شود.
* اگر فایل اصلی حذف شود، لینک نمادین به فایل غیرموجود اشاره می‌کند و اصطلاحاً **شکسته (Broken Link)** می‌شود.
* در خروجی `ls -l`، لینک‌های نمادین با حرف **`l`** در ابتدای خط مشخص می‌شوند و با پیکان **`→`** مسیر هدف را نشان می‌دهند.
* در بسیاری از محیط‌های لینوکسی، لینک‌های شکسته با رنگ قرمز نمایش داده می‌شوند.

---

### مثال:

```bash
ln -s /home/user/file.txt link1
```

در این مثال، `link1` یک لینک نمادین به فایل `file.txt` است.
اگر فایل اصلی حذف شود، `link1` باقی می‌ماند اما دیگر به چیزی اشاره نمی‌کند.

---

## تفاوت لینک سخت و لینک نمادین

| ویژگی                           | لینک سخت (Hard Link)                            | لینک نمادین (Symbolic Link)                 |
| ------------------------------- | ----------------------------------------------- | ------------------------------------------- |
| **ارتباط با فایل اصلی**         | مستقیماً به داده (**inode**) فایل اشاره می‌کند. | فقط مسیر فایل را ذخیره می‌کند.              |
| **قابل اعمال روی دایرکتوری‌ها** | ❌ خیر                                           | ✅ بله                                       |
| **قابل استفاده بین پارتیشن‌ها** | ❌ خیر                                           | ✅ بله                                       |
| **نمایش در `ls -l`**            | شبیه فایل عادی است.                             | با حرف `l` و پیکان (`→`) نمایش داده می‌شود. |
| **رفتار هنگام حذف فایل اصلی**   | فایل همچنان وجود دارد تا آخرین لینک حذف شود.    | لینک شکسته می‌شود (**Broken Link**).        |
| **ایجاد با دستور**              | `ln file link`                                  | `ln -s item link`                           |

---

📘 **نکته حرفه‌ای:**
در سیستم‌های مدرن لینوکس تقریباً همیشه از **Symbolic Links** استفاده می‌شود،
زیرا انعطاف‌پذیرتر و قابل استفاده برای فایل‌ها، دایرکتوری‌ها و حتی در پارتیشن‌های مختلف هستند.

---

### 🟢 پایان بخش هفتم

در بخش بعدی (و آخر فصل)، وارد بخش تمرین عملی **Playground** می‌شویم،
جایی که با استفاده از دستورات `mkdir`, `cp`, `mv`, `ln`, و `rm`
به‌صورت گام‌به‌گام تمرین خواهیم کرد تا مفاهیم کاملاً جا بیفتد.


# بیایید یک محیط تمرینی بسازیم (Let's Build a Playground)

از آن‌جا که در این فصل قرار است واقعاً با فایل‌ها و پوشه‌ها کار کنیم،
بهتر است یک محیط امن برای تمرین بسازیم تا بدون ترس از خراب کردن سیستم،
بتوانیم همه‌ی دستورات را امتحان کنیم.

---

## ایجاد دایرکتوری‌ها (Creating Directories)

ابتدا مطمئن می‌شویم که در دایرکتوری خانگی خود هستیم و سپس پوشه‌ی **playground** را می‌سازیم:

```bash
[me@linuxbox ~]$ cd
[me@linuxbox ~]$ mkdir playground
```

حالا برای جذاب‌تر شدن تمرین، دو پوشه‌ی دیگر به نام‌های **dir1** و **dir2** درون آن ایجاد می‌کنیم.
برای این کار، ابتدا وارد **playground** می‌شویم و سپس هر دو پوشه را با یک دستور می‌سازیم:

```bash
[me@linuxbox ~]$ cd playground
[me@linuxbox playground]$ mkdir dir1 dir2
```

✅ **نکته:** دستور `mkdir` می‌تواند چند آرگومان بپذیرد و در نتیجه با یک دستور چند پوشه را هم‌زمان بسازد.

---

## کپی کردن فایل‌ها (Copying Files)

اکنون باید کمی داده در محیط تمرینی خود داشته باشیم.
برای این منظور، از دستور `cp` استفاده می‌کنیم تا یک فایل سیستمی را کپی کنیم.

به‌عنوان مثال، فایل `/etc/passwd` را از مسیر اصلی سیستم به دایرکتوری فعلی کپی می‌کنیم:

```bash
[me@linuxbox playground]$ cp /etc/passwd .
```

در اینجا از `.` به‌عنوان میان‌بر دایرکتوری فعلی (**current directory**) استفاده کرده‌ایم.
اگر اکنون دستور زیر را اجرا کنیم، فایل جدید را خواهیم دید:

```bash
[me@linuxbox playground]$ ls -l
```

خروجی:

```
total 12
drwxrwxr-x 2 me me 4096 2025-01-10 16:40 dir1
drwxrwxr-x 2 me me 4096 2025-01-10 16:40 dir2
-rw-r--r-- 1 me me 1650 2025-01-10 16:07 passwd
```

---

### استفاده از گزینه `-v` برای مشاهده‌ی عملیات

بیایید همان کپی را این بار با گزینه‌ی **`-v` (verbose)** انجام دهیم تا پیام توضیحی ببینیم:

```bash
[me@linuxbox playground]$ cp -v /etc/passwd .
‘/etc/passwd’ -> ‘./passwd’
```

در این حالت، `cp` همان عملیات کپی را انجام می‌دهد ولی یک پیام کوتاه نشان می‌دهد که چه کاری در حال انجام است.
توجه کنید که `cp` نسخه‌ی قبلی فایل را بدون هیچ هشداری بازنویسی کرده است.
برای دریافت هشدار پیش از بازنویسی، از گزینه‌ی `-i` استفاده می‌کنیم:

```bash
[me@linuxbox playground]$ cp -i /etc/passwd .
cp: overwrite ‘./passwd’?
```

اگر در پاسخ `y` وارد کنیم، فایل بازنویسی می‌شود؛
در غیر این صورت (مثلاً با `n`) فایل بدون تغییر باقی می‌ماند.

---

## جابه‌جایی و تغییر نام فایل‌ها (Moving and Renaming Files)

اکنون فایل **passwd** را به نامی بامزه‌تر تغییر می‌دهیم تا تمرین ادامه پیدا کند:

```bash
[me@linuxbox playground]$ mv passwd fun
```

سپس فایل **fun** را بین پوشه‌ها جابه‌جا می‌کنیم:

```bash
[me@linuxbox playground]$ mv fun dir1
[me@linuxbox playground]$ mv dir1/fun dir2
[me@linuxbox playground]$ mv dir2/fun .
```

اکنون فایل دوباره به محل اصلی بازگشته است.

---

### جابه‌جایی پوشه‌ها

بیایید ببینیم `mv` روی دایرکتوری‌ها چه اثری دارد.

ابتدا فایل fun را دوباره به dir1 منتقل می‌کنیم:

```bash
[me@linuxbox playground]$ mv fun dir1
```

سپس پوشه‌ی dir1 را به درون dir2 منتقل می‌کنیم:

```bash
[me@linuxbox playground]$ mv dir1 dir2
```

و حالا با `ls` بررسی می‌کنیم:

```bash
[me@linuxbox playground]$ ls -l dir2
total 4
drwxrwxr-x 2 me me 4096 2025-01-11 06:06 dir1
```

درون آن را نیز ببینیم:

```bash
[me@linuxbox playground]$ ls -l dir2/dir1
total 4
-rw-r--r-- 1 me me 1650 2025-01-10 16:33 fun
```

چون dir2 وجود داشت، mv پوشه‌ی dir1 را به داخل آن منتقل کرد.
اگر dir2 وجود نداشت، نام dir1 به dir2 تغییر می‌کرد.

در نهایت، همه‌چیز را به حالت اولیه بازمی‌گردانیم:

```bash
[me@linuxbox playground]$ mv dir2/dir1 .
[me@linuxbox playground]$ mv dir1/fun .
```

---

## ایجاد لینک‌های سخت (Creating Hard Links)

چند لینک سخت به فایل fun ایجاد می‌کنیم:

```bash
[me@linuxbox playground]$ ln fun fun-hard
[me@linuxbox playground]$ ln fun dir1/fun-hard
[me@linuxbox playground]$ ln fun dir2/fun-hard
```

اکنون چهار نسخه از فایل fun داریم.
با `ls -l` وضعیت را بررسی می‌کنیم:

```
total 16
drwxrwxr-x 2 me me 4096 2025-01-14 16:17 dir1
drwxrwxr-x 2 me me 4096 2025-01-14 16:17 dir2
-rw-r--r-- 4 me me 1650 2025-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2025-01-10 16:33 fun-hard
```

عدد ۴ در ستون دوم نشان‌دهنده‌ی تعداد لینک‌های سخت است.

---

### مشاهده‌ی شماره inode فایل‌ها

برای اطمینان از اینکه دو فایل واقعاً یکی هستند، از گزینه‌ی `-i` در دستور `ls` استفاده می‌کنیم:

```bash
[me@linuxbox playground]$ ls -li
```

خروجی نمونه:

```
12353538 -rw-r--r-- 4 me me 1650 2025-01-10 16:33 fun
12353538 -rw-r--r-- 4 me me 1650 2025-01-10 16:33 fun-hard
```

هر دو فایل شماره‌ی inode یکسان دارند (12353538)، که ثابت می‌کند هر دو اشاره به یک فایل واحد هستند.

---

## ایجاد لینک‌های نمادین (Creating Symbolic Links)

```bash
[me@linuxbox playground]$ ln -s fun fun-sym
[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym
[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym
```

در این مثال:

* `fun-sym` در دایرکتوری فعلی به فایل fun اشاره دارد.
* لینک‌های داخل dir1 و dir2 مسیر نسبی (**../fun**) دارند.

خروجی:

```
-rw-r--r-- 4 me me 1650 2025-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me 6 2025-01-15 15:17 fun-sym -> ../fun
```

حرف `l` در ابتدای خط نشان می‌دهد که `fun-sym` یک لینک نمادین است
و پیکان (`->`) مسیر هدف را نشان می‌دهد.

---

## حذف فایل‌ها و لینک‌ها (Removing Files and Links)

ابتدا یکی از لینک‌های سخت را حذف می‌کنیم:

```bash
[me@linuxbox playground]$ rm fun-hard
```

سپس بررسی می‌کنیم:

```bash
[me@linuxbox playground]$ ls -l
```

می‌بینیم که `fun-hard` حذف شده و شمار لینک‌های فایل `fun` از ۴ به ۳ کاهش یافته است.

اکنون فایل اصلی را با گزینه‌ی `-i` حذف می‌کنیم:

```bash
[me@linuxbox playground]$ rm -i fun
rm: remove regular file ‘fun’?
```

با وارد کردن `y` فایل حذف می‌شود.
حال اگر دوباره `ls -l` را ببینیم، لینک `fun-sym` اکنون شکسته (broken) است.

---

### حذف لینک‌های نمادین

```bash
[me@linuxbox playground]$ rm fun-sym dir1-sym
```

و در پایان فقط دو پوشه‌ی خالی باقی می‌ماند.

---

## حذف کامل محیط تمرینی (Cleaning Up)

برای حذف کل محیط تمرینی:

```bash
[me@linuxbox playground]$ cd
[me@linuxbox ~]$ rm -r playground
```

---

## ایجاد لینک‌ها در محیط گرافیکی (Creating Symlinks With the GUI)

در محیط‌های گرافیکی لینوکس نیز می‌توان لینک‌ها را به‌سادگی ساخت:

* در **GNOME (Nautilus):** هنگام کشیدن یک فایل، کلیدهای `Ctrl + Shift` را نگه دارید.
  به‌جای کپی یا انتقال، یک لینک نمادین ساخته می‌شود.
* در **KDE (Dolphin / Konqueror):** هنگام رها کردن فایل، منویی ظاهر می‌شود که گزینه‌های **Copy**, **Move** و **Link** را ارائه می‌دهد.

---

## جمع‌بندی (Summing Up)

در این فصل آموختیم چگونه فایل‌ها و دایرکتوری‌ها را در لینوکس مدیریت کنیم.
برای تسلط کامل، تمرین‌های **playground** را چندین بار تکرار کنید تا تمام مفاهیم جا بیفتد.

### دستورات کلیدی:

* `cp` → برای کپی کردن فایل‌ها
* `mv` → برای جابه‌جا کردن و تغییر نام
* `rm` → برای حذف
* `mkdir` → برای ساخت دایرکتوری
* `ln` → برای ایجاد لینک‌ها

همچنین یاد گرفتیم چگونه از **wildcards** برای انتخاب گروهی از فایل‌ها استفاده کنیم.
مفهوم لینک‌ها (به‌ویژه لینک‌های نمادین) در ابتدا کمی گیج‌کننده است،
اما درک درست آن‌ها یکی از مهارت‌های کلیدی در کار با لینوکس است.

---

## منابع پیشنهادی (Further Reading)

* 🔗 [Symbolic link – Wikipedia](https://en.wikipedia.org/wiki/Symbolic_link)
* 📘 *The Linux Command Line – William Shotts*
